// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: algo.proto

#ifndef PROTOBUF_algo_2eproto__INCLUDED
#define PROTOBUF_algo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace bvdt {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_algo_2eproto();
void protobuf_AssignDesc_algo_2eproto();
void protobuf_ShutdownFile_algo_2eproto();

class SolverParameter;
class NodeParameter;
class TreeParameter;

enum SolverParameter_RegularizationType {
  SolverParameter_RegularizationType_NO_REGULARIZATION = 0,
  SolverParameter_RegularizationType_L1_REGULARIZATION = 1,
  SolverParameter_RegularizationType_L2_REGULARIZATION = 2,
  SolverParameter_RegularizationType_L1L2_REGULARIZATION = 3
};
bool SolverParameter_RegularizationType_IsValid(int value);
const SolverParameter_RegularizationType SolverParameter_RegularizationType_RegularizationType_MIN = SolverParameter_RegularizationType_NO_REGULARIZATION;
const SolverParameter_RegularizationType SolverParameter_RegularizationType_RegularizationType_MAX = SolverParameter_RegularizationType_L1L2_REGULARIZATION;
const int SolverParameter_RegularizationType_RegularizationType_ARRAYSIZE = SolverParameter_RegularizationType_RegularizationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SolverParameter_RegularizationType_descriptor();
inline const ::std::string& SolverParameter_RegularizationType_Name(SolverParameter_RegularizationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SolverParameter_RegularizationType_descriptor(), value);
}
inline bool SolverParameter_RegularizationType_Parse(
    const ::std::string& name, SolverParameter_RegularizationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolverParameter_RegularizationType>(
    SolverParameter_RegularizationType_descriptor(), name, value);
}
enum SolverParameter_DirectionType {
  SolverParameter_DirectionType_FULL_SEARCH = 0,
  SolverParameter_DirectionType_ALTERNATIVE = 1
};
bool SolverParameter_DirectionType_IsValid(int value);
const SolverParameter_DirectionType SolverParameter_DirectionType_DirectionType_MIN = SolverParameter_DirectionType_FULL_SEARCH;
const SolverParameter_DirectionType SolverParameter_DirectionType_DirectionType_MAX = SolverParameter_DirectionType_ALTERNATIVE;
const int SolverParameter_DirectionType_DirectionType_ARRAYSIZE = SolverParameter_DirectionType_DirectionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SolverParameter_DirectionType_descriptor();
inline const ::std::string& SolverParameter_DirectionType_Name(SolverParameter_DirectionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SolverParameter_DirectionType_descriptor(), value);
}
inline bool SolverParameter_DirectionType_Parse(
    const ::std::string& name, SolverParameter_DirectionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolverParameter_DirectionType>(
    SolverParameter_DirectionType_descriptor(), name, value);
}
enum SolverParameter_LeafValueData {
  SolverParameter_LeafValueData_SAMPLE_DATA = 0,
  SolverParameter_LeafValueData_ALL_DATA = 1
};
bool SolverParameter_LeafValueData_IsValid(int value);
const SolverParameter_LeafValueData SolverParameter_LeafValueData_LeafValueData_MIN = SolverParameter_LeafValueData_SAMPLE_DATA;
const SolverParameter_LeafValueData SolverParameter_LeafValueData_LeafValueData_MAX = SolverParameter_LeafValueData_ALL_DATA;
const int SolverParameter_LeafValueData_LeafValueData_ARRAYSIZE = SolverParameter_LeafValueData_LeafValueData_MAX + 1;

const ::google::protobuf::EnumDescriptor* SolverParameter_LeafValueData_descriptor();
inline const ::std::string& SolverParameter_LeafValueData_Name(SolverParameter_LeafValueData value) {
  return ::google::protobuf::internal::NameOfEnum(
    SolverParameter_LeafValueData_descriptor(), value);
}
inline bool SolverParameter_LeafValueData_Parse(
    const ::std::string& name, SolverParameter_LeafValueData* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolverParameter_LeafValueData>(
    SolverParameter_LeafValueData_descriptor(), name, value);
}
enum SolverParameter_NodeSplitType {
  SolverParameter_NodeSplitType_NEWTON = 0,
  SolverParameter_NodeSplitType_GRADIENT = 1
};
bool SolverParameter_NodeSplitType_IsValid(int value);
const SolverParameter_NodeSplitType SolverParameter_NodeSplitType_NodeSplitType_MIN = SolverParameter_NodeSplitType_NEWTON;
const SolverParameter_NodeSplitType SolverParameter_NodeSplitType_NodeSplitType_MAX = SolverParameter_NodeSplitType_GRADIENT;
const int SolverParameter_NodeSplitType_NodeSplitType_ARRAYSIZE = SolverParameter_NodeSplitType_NodeSplitType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SolverParameter_NodeSplitType_descriptor();
inline const ::std::string& SolverParameter_NodeSplitType_Name(SolverParameter_NodeSplitType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SolverParameter_NodeSplitType_descriptor(), value);
}
inline bool SolverParameter_NodeSplitType_Parse(
    const ::std::string& name, SolverParameter_NodeSplitType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolverParameter_NodeSplitType>(
    SolverParameter_NodeSplitType_descriptor(), name, value);
}
enum NodeParameter_NodeType {
  NodeParameter_NodeType_INTERNAL = 0,
  NodeParameter_NodeType_LEAF = 1,
  NodeParameter_NodeType_UNDEF = 2
};
bool NodeParameter_NodeType_IsValid(int value);
const NodeParameter_NodeType NodeParameter_NodeType_NodeType_MIN = NodeParameter_NodeType_INTERNAL;
const NodeParameter_NodeType NodeParameter_NodeType_NodeType_MAX = NodeParameter_NodeType_UNDEF;
const int NodeParameter_NodeType_NodeType_ARRAYSIZE = NodeParameter_NodeType_NodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeParameter_NodeType_descriptor();
inline const ::std::string& NodeParameter_NodeType_Name(NodeParameter_NodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeParameter_NodeType_descriptor(), value);
}
inline bool NodeParameter_NodeType_Parse(
    const ::std::string& name, NodeParameter_NodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeParameter_NodeType>(
    NodeParameter_NodeType_descriptor(), name, value);
}
enum __NodeMode_ {
  ONE_VS_ONE = 0,
  ONE_VS_ALL = 1,
  ONE_VS_ALL_R = 2
};
bool __NodeMode__IsValid(int value);
const __NodeMode_ __NodeMode__MIN = ONE_VS_ONE;
const __NodeMode_ __NodeMode__MAX = ONE_VS_ALL_R;
const int __NodeMode__ARRAYSIZE = __NodeMode__MAX + 1;

const ::google::protobuf::EnumDescriptor* __NodeMode__descriptor();
inline const ::std::string& __NodeMode__Name(__NodeMode_ value) {
  return ::google::protobuf::internal::NameOfEnum(
    __NodeMode__descriptor(), value);
}
inline bool __NodeMode__Parse(
    const ::std::string& name, __NodeMode_* value) {
  return ::google::protobuf::internal::ParseNamedEnum<__NodeMode_>(
    __NodeMode__descriptor(), name, value);
}
// ===================================================================

class SolverParameter : public ::google::protobuf::Message {
 public:
  SolverParameter();
  virtual ~SolverParameter();

  SolverParameter(const SolverParameter& from);

  inline SolverParameter& operator=(const SolverParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolverParameter& default_instance();

  void Swap(SolverParameter* other);

  // implements Message ----------------------------------------------

  SolverParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SolverParameter& from);
  void MergeFrom(const SolverParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SolverParameter_RegularizationType RegularizationType;
  static const RegularizationType NO_REGULARIZATION = SolverParameter_RegularizationType_NO_REGULARIZATION;
  static const RegularizationType L1_REGULARIZATION = SolverParameter_RegularizationType_L1_REGULARIZATION;
  static const RegularizationType L2_REGULARIZATION = SolverParameter_RegularizationType_L2_REGULARIZATION;
  static const RegularizationType L1L2_REGULARIZATION = SolverParameter_RegularizationType_L1L2_REGULARIZATION;
  static inline bool RegularizationType_IsValid(int value) {
    return SolverParameter_RegularizationType_IsValid(value);
  }
  static const RegularizationType RegularizationType_MIN =
    SolverParameter_RegularizationType_RegularizationType_MIN;
  static const RegularizationType RegularizationType_MAX =
    SolverParameter_RegularizationType_RegularizationType_MAX;
  static const int RegularizationType_ARRAYSIZE =
    SolverParameter_RegularizationType_RegularizationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RegularizationType_descriptor() {
    return SolverParameter_RegularizationType_descriptor();
  }
  static inline const ::std::string& RegularizationType_Name(RegularizationType value) {
    return SolverParameter_RegularizationType_Name(value);
  }
  static inline bool RegularizationType_Parse(const ::std::string& name,
      RegularizationType* value) {
    return SolverParameter_RegularizationType_Parse(name, value);
  }

  typedef SolverParameter_DirectionType DirectionType;
  static const DirectionType FULL_SEARCH = SolverParameter_DirectionType_FULL_SEARCH;
  static const DirectionType ALTERNATIVE = SolverParameter_DirectionType_ALTERNATIVE;
  static inline bool DirectionType_IsValid(int value) {
    return SolverParameter_DirectionType_IsValid(value);
  }
  static const DirectionType DirectionType_MIN =
    SolverParameter_DirectionType_DirectionType_MIN;
  static const DirectionType DirectionType_MAX =
    SolverParameter_DirectionType_DirectionType_MAX;
  static const int DirectionType_ARRAYSIZE =
    SolverParameter_DirectionType_DirectionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DirectionType_descriptor() {
    return SolverParameter_DirectionType_descriptor();
  }
  static inline const ::std::string& DirectionType_Name(DirectionType value) {
    return SolverParameter_DirectionType_Name(value);
  }
  static inline bool DirectionType_Parse(const ::std::string& name,
      DirectionType* value) {
    return SolverParameter_DirectionType_Parse(name, value);
  }

  typedef SolverParameter_LeafValueData LeafValueData;
  static const LeafValueData SAMPLE_DATA = SolverParameter_LeafValueData_SAMPLE_DATA;
  static const LeafValueData ALL_DATA = SolverParameter_LeafValueData_ALL_DATA;
  static inline bool LeafValueData_IsValid(int value) {
    return SolverParameter_LeafValueData_IsValid(value);
  }
  static const LeafValueData LeafValueData_MIN =
    SolverParameter_LeafValueData_LeafValueData_MIN;
  static const LeafValueData LeafValueData_MAX =
    SolverParameter_LeafValueData_LeafValueData_MAX;
  static const int LeafValueData_ARRAYSIZE =
    SolverParameter_LeafValueData_LeafValueData_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LeafValueData_descriptor() {
    return SolverParameter_LeafValueData_descriptor();
  }
  static inline const ::std::string& LeafValueData_Name(LeafValueData value) {
    return SolverParameter_LeafValueData_Name(value);
  }
  static inline bool LeafValueData_Parse(const ::std::string& name,
      LeafValueData* value) {
    return SolverParameter_LeafValueData_Parse(name, value);
  }

  typedef SolverParameter_NodeSplitType NodeSplitType;
  static const NodeSplitType NEWTON = SolverParameter_NodeSplitType_NEWTON;
  static const NodeSplitType GRADIENT = SolverParameter_NodeSplitType_GRADIENT;
  static inline bool NodeSplitType_IsValid(int value) {
    return SolverParameter_NodeSplitType_IsValid(value);
  }
  static const NodeSplitType NodeSplitType_MIN =
    SolverParameter_NodeSplitType_NodeSplitType_MIN;
  static const NodeSplitType NodeSplitType_MAX =
    SolverParameter_NodeSplitType_NodeSplitType_MAX;
  static const int NodeSplitType_ARRAYSIZE =
    SolverParameter_NodeSplitType_NodeSplitType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NodeSplitType_descriptor() {
    return SolverParameter_NodeSplitType_descriptor();
  }
  static inline const ::std::string& NodeSplitType_Name(NodeSplitType value) {
    return SolverParameter_NodeSplitType_Name(value);
  }
  static inline bool NodeSplitType_Parse(const ::std::string& name,
      NodeSplitType* value) {
    return SolverParameter_NodeSplitType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 nleaves = 1;
  inline bool has_nleaves() const;
  inline void clear_nleaves();
  static const int kNleavesFieldNumber = 1;
  inline ::google::protobuf::int32 nleaves() const;
  inline void set_nleaves(::google::protobuf::int32 value);

  // optional float convergence_rate = 36 [default = 0];
  inline bool has_convergence_rate() const;
  inline void clear_convergence_rate();
  static const int kConvergenceRateFieldNumber = 36;
  inline float convergence_rate() const;
  inline void set_convergence_rate(float value);

  // required int32 nclass_label = 2;
  inline bool has_nclass_label() const;
  inline void clear_nclass_label();
  static const int kNclassLabelFieldNumber = 2;
  inline ::google::protobuf::int32 nclass_label() const;
  inline void set_nclass_label(::google::protobuf::int32 value);

  // required int32 nfeatures = 16;
  inline bool has_nfeatures() const;
  inline void clear_nfeatures();
  static const int kNfeaturesFieldNumber = 16;
  inline ::google::protobuf::int32 nfeatures() const;
  inline void set_nfeatures(::google::protobuf::int32 value);

  // required int32 nmaximum_trees = 22;
  inline bool has_nmaximum_trees() const;
  inline void clear_nmaximum_trees();
  static const int kNmaximumTreesFieldNumber = 22;
  inline ::google::protobuf::int32 nmaximum_trees() const;
  inline void set_nmaximum_trees(::google::protobuf::int32 value);

  // optional float maxz = 3 [default = 4];
  inline bool has_maxz() const;
  inline void clear_maxz();
  static const int kMaxzFieldNumber = 3;
  inline float maxz() const;
  inline void set_maxz(float value);

  // optional float shrinkage = 11 [default = 1];
  inline bool has_shrinkage() const;
  inline void clear_shrinkage();
  static const int kShrinkageFieldNumber = 11;
  inline float shrinkage() const;
  inline void set_shrinkage(float value);

  // required string snapshot = 18;
  inline bool has_snapshot() const;
  inline void clear_snapshot();
  static const int kSnapshotFieldNumber = 18;
  inline const ::std::string& snapshot() const;
  inline void set_snapshot(const ::std::string& value);
  inline void set_snapshot(const char* value);
  inline void set_snapshot(const char* value, size_t size);
  inline ::std::string* mutable_snapshot();
  inline ::std::string* release_snapshot();
  inline void set_allocated_snapshot(::std::string* snapshot);

  // optional int32 snapshot_interval = 17 [default = 100];
  inline bool has_snapshot_interval() const;
  inline void clear_snapshot_interval();
  static const int kSnapshotIntervalFieldNumber = 17;
  inline ::google::protobuf::int32 snapshot_interval() const;
  inline void set_snapshot_interval(::google::protobuf::int32 value);

  // optional int32 reshuffle_interval = 35 [default = 0];
  inline bool has_reshuffle_interval() const;
  inline void clear_reshuffle_interval();
  static const int kReshuffleIntervalFieldNumber = 35;
  inline ::google::protobuf::int32 reshuffle_interval() const;
  inline void set_reshuffle_interval(::google::protobuf::int32 value);

  // required string train_data = 20;
  inline bool has_train_data() const;
  inline void clear_train_data();
  static const int kTrainDataFieldNumber = 20;
  inline const ::std::string& train_data() const;
  inline void set_train_data(const ::std::string& value);
  inline void set_train_data(const char* value);
  inline void set_train_data(const char* value, size_t size);
  inline ::std::string* mutable_train_data();
  inline ::std::string* release_train_data();
  inline void set_allocated_train_data(::std::string* train_data);

  // required int32 ntrain_samples = 28;
  inline bool has_ntrain_samples() const;
  inline void clear_ntrain_samples();
  static const int kNtrainSamplesFieldNumber = 28;
  inline ::google::protobuf::int32 ntrain_samples() const;
  inline void set_ntrain_samples(::google::protobuf::int32 value);

  // optional string test_data = 21;
  inline bool has_test_data() const;
  inline void clear_test_data();
  static const int kTestDataFieldNumber = 21;
  inline const ::std::string& test_data() const;
  inline void set_test_data(const ::std::string& value);
  inline void set_test_data(const char* value);
  inline void set_test_data(const char* value, size_t size);
  inline ::std::string* mutable_test_data();
  inline ::std::string* release_test_data();
  inline void set_allocated_test_data(::std::string* test_data);

  // optional int32 ntest_samples = 29;
  inline bool has_ntest_samples() const;
  inline void clear_ntest_samples();
  static const int kNtestSamplesFieldNumber = 29;
  inline ::google::protobuf::int32 ntest_samples() const;
  inline void set_ntest_samples(::google::protobuf::int32 value);

  // optional int32 display = 33 [default = 1];
  inline bool has_display() const;
  inline void clear_display();
  static const int kDisplayFieldNumber = 33;
  inline ::google::protobuf::int32 display() const;
  inline void set_display(::google::protobuf::int32 value);

  // optional bool save_accuracy = 34 [default = false];
  inline bool has_save_accuracy() const;
  inline void clear_save_accuracy();
  static const int kSaveAccuracyFieldNumber = 34;
  inline bool save_accuracy() const;
  inline void set_save_accuracy(bool value);

  // optional .bvdt.SolverParameter.RegularizationType regularization_type_split = 12 [default = NO_REGULARIZATION];
  inline bool has_regularization_type_split() const;
  inline void clear_regularization_type_split();
  static const int kRegularizationTypeSplitFieldNumber = 12;
  inline ::bvdt::SolverParameter_RegularizationType regularization_type_split() const;
  inline void set_regularization_type_split(::bvdt::SolverParameter_RegularizationType value);

  // optional float regularization_split = 13;
  inline bool has_regularization_split() const;
  inline void clear_regularization_split();
  static const int kRegularizationSplitFieldNumber = 13;
  inline float regularization_split() const;
  inline void set_regularization_split(float value);

  // optional float regularization_ratio_split = 14;
  inline bool has_regularization_ratio_split() const;
  inline void clear_regularization_ratio_split();
  static const int kRegularizationRatioSplitFieldNumber = 14;
  inline float regularization_ratio_split() const;
  inline void set_regularization_ratio_split(float value);

  // optional .bvdt.SolverParameter.RegularizationType regularization_type_leaf = 30 [default = NO_REGULARIZATION];
  inline bool has_regularization_type_leaf() const;
  inline void clear_regularization_type_leaf();
  static const int kRegularizationTypeLeafFieldNumber = 30;
  inline ::bvdt::SolverParameter_RegularizationType regularization_type_leaf() const;
  inline void set_regularization_type_leaf(::bvdt::SolverParameter_RegularizationType value);

  // optional float regularization_leaf = 31;
  inline bool has_regularization_leaf() const;
  inline void clear_regularization_leaf();
  static const int kRegularizationLeafFieldNumber = 31;
  inline float regularization_leaf() const;
  inline void set_regularization_leaf(float value);

  // optional float regularization_ratio_leaf = 32;
  inline bool has_regularization_ratio_leaf() const;
  inline void clear_regularization_ratio_leaf();
  static const int kRegularizationRatioLeafFieldNumber = 32;
  inline float regularization_ratio_leaf() const;
  inline void set_regularization_ratio_leaf(float value);

  // required float event_sample_rate = 4 [default = 1];
  inline bool has_event_sample_rate() const;
  inline void clear_event_sample_rate();
  static const int kEventSampleRateFieldNumber = 4;
  inline float event_sample_rate() const;
  inline void set_event_sample_rate(float value);

  // required float node_mode_sample_rate = 5 [default = 1];
  inline bool has_node_mode_sample_rate() const;
  inline void clear_node_mode_sample_rate();
  static const int kNodeModeSampleRateFieldNumber = 5;
  inline float node_mode_sample_rate() const;
  inline void set_node_mode_sample_rate(float value);

  // required float feature_sample_rate = 6 [default = 1];
  inline bool has_feature_sample_rate() const;
  inline void clear_feature_sample_rate();
  static const int kFeatureSampleRateFieldNumber = 6;
  inline float feature_sample_rate() const;
  inline void set_feature_sample_rate(float value);

  // required .bvdt.SolverParameter.DirectionType direction_type = 15 [default = FULL_SEARCH];
  inline bool has_direction_type() const;
  inline void clear_direction_type();
  static const int kDirectionTypeFieldNumber = 15;
  inline ::bvdt::SolverParameter_DirectionType direction_type() const;
  inline void set_direction_type(::bvdt::SolverParameter_DirectionType value);

  // required .bvdt.SolverParameter.LeafValueData leaf_value_data = 7;
  inline bool has_leaf_value_data() const;
  inline void clear_leaf_value_data();
  static const int kLeafValueDataFieldNumber = 7;
  inline ::bvdt::SolverParameter_LeafValueData leaf_value_data() const;
  inline void set_leaf_value_data(::bvdt::SolverParameter_LeafValueData value);

  // required .bvdt.SolverParameter.NodeSplitType node_split_type = 8;
  inline bool has_node_split_type() const;
  inline void clear_node_split_type();
  static const int kNodeSplitTypeFieldNumber = 8;
  inline ::bvdt::SolverParameter_NodeSplitType node_split_type() const;
  inline void set_node_split_type(::bvdt::SolverParameter_NodeSplitType value);

  // required .bvdt.SolverParameter.NodeSplitType leaf_value_type = 27;
  inline bool has_leaf_value_type() const;
  inline void clear_leaf_value_type();
  static const int kLeafValueTypeFieldNumber = 27;
  inline ::bvdt::SolverParameter_NodeSplitType leaf_value_type() const;
  inline void set_leaf_value_type(::bvdt::SolverParameter_NodeSplitType value);

  // required .bvdt.__NodeMode_ node_type = 9;
  inline bool has_node_type() const;
  inline void clear_node_type();
  static const int kNodeTypeFieldNumber = 9;
  inline ::bvdt::__NodeMode_ node_type() const;
  inline void set_node_type(::bvdt::__NodeMode_ value);

  // repeated float node_mode_param = 37;
  inline int node_mode_param_size() const;
  inline void clear_node_mode_param();
  static const int kNodeModeParamFieldNumber = 37;
  inline float node_mode_param(int index) const;
  inline void set_node_mode_param(int index, float value);
  inline void add_node_mode_param(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      node_mode_param() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_node_mode_param();

  // @@protoc_insertion_point(class_scope:bvdt.SolverParameter)
 private:
  inline void set_has_nleaves();
  inline void clear_has_nleaves();
  inline void set_has_convergence_rate();
  inline void clear_has_convergence_rate();
  inline void set_has_nclass_label();
  inline void clear_has_nclass_label();
  inline void set_has_nfeatures();
  inline void clear_has_nfeatures();
  inline void set_has_nmaximum_trees();
  inline void clear_has_nmaximum_trees();
  inline void set_has_maxz();
  inline void clear_has_maxz();
  inline void set_has_shrinkage();
  inline void clear_has_shrinkage();
  inline void set_has_snapshot();
  inline void clear_has_snapshot();
  inline void set_has_snapshot_interval();
  inline void clear_has_snapshot_interval();
  inline void set_has_reshuffle_interval();
  inline void clear_has_reshuffle_interval();
  inline void set_has_train_data();
  inline void clear_has_train_data();
  inline void set_has_ntrain_samples();
  inline void clear_has_ntrain_samples();
  inline void set_has_test_data();
  inline void clear_has_test_data();
  inline void set_has_ntest_samples();
  inline void clear_has_ntest_samples();
  inline void set_has_display();
  inline void clear_has_display();
  inline void set_has_save_accuracy();
  inline void clear_has_save_accuracy();
  inline void set_has_regularization_type_split();
  inline void clear_has_regularization_type_split();
  inline void set_has_regularization_split();
  inline void clear_has_regularization_split();
  inline void set_has_regularization_ratio_split();
  inline void clear_has_regularization_ratio_split();
  inline void set_has_regularization_type_leaf();
  inline void clear_has_regularization_type_leaf();
  inline void set_has_regularization_leaf();
  inline void clear_has_regularization_leaf();
  inline void set_has_regularization_ratio_leaf();
  inline void clear_has_regularization_ratio_leaf();
  inline void set_has_event_sample_rate();
  inline void clear_has_event_sample_rate();
  inline void set_has_node_mode_sample_rate();
  inline void clear_has_node_mode_sample_rate();
  inline void set_has_feature_sample_rate();
  inline void clear_has_feature_sample_rate();
  inline void set_has_direction_type();
  inline void clear_has_direction_type();
  inline void set_has_leaf_value_data();
  inline void clear_has_leaf_value_data();
  inline void set_has_node_split_type();
  inline void clear_has_node_split_type();
  inline void set_has_leaf_value_type();
  inline void clear_has_leaf_value_type();
  inline void set_has_node_type();
  inline void clear_has_node_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 nleaves_;
  float convergence_rate_;
  ::google::protobuf::int32 nclass_label_;
  ::google::protobuf::int32 nfeatures_;
  ::google::protobuf::int32 nmaximum_trees_;
  float maxz_;
  ::std::string* snapshot_;
  float shrinkage_;
  ::google::protobuf::int32 snapshot_interval_;
  ::std::string* train_data_;
  ::google::protobuf::int32 reshuffle_interval_;
  ::google::protobuf::int32 ntrain_samples_;
  ::std::string* test_data_;
  ::google::protobuf::int32 ntest_samples_;
  ::google::protobuf::int32 display_;
  bool save_accuracy_;
  int regularization_type_split_;
  float regularization_split_;
  float regularization_ratio_split_;
  int regularization_type_leaf_;
  float regularization_leaf_;
  float regularization_ratio_leaf_;
  float event_sample_rate_;
  float node_mode_sample_rate_;
  float feature_sample_rate_;
  int direction_type_;
  int leaf_value_data_;
  int node_split_type_;
  int leaf_value_type_;
  ::google::protobuf::RepeatedField< float > node_mode_param_;
  int node_type_;
  friend void  protobuf_AddDesc_algo_2eproto();
  friend void protobuf_AssignDesc_algo_2eproto();
  friend void protobuf_ShutdownFile_algo_2eproto();

  void InitAsDefaultInstance();
  static SolverParameter* default_instance_;
};
// -------------------------------------------------------------------

class NodeParameter : public ::google::protobuf::Message {
 public:
  NodeParameter();
  virtual ~NodeParameter();

  NodeParameter(const NodeParameter& from);

  inline NodeParameter& operator=(const NodeParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeParameter& default_instance();

  void Swap(NodeParameter* other);

  // implements Message ----------------------------------------------

  NodeParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeParameter& from);
  void MergeFrom(const NodeParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NodeParameter_NodeType NodeType;
  static const NodeType INTERNAL = NodeParameter_NodeType_INTERNAL;
  static const NodeType LEAF = NodeParameter_NodeType_LEAF;
  static const NodeType UNDEF = NodeParameter_NodeType_UNDEF;
  static inline bool NodeType_IsValid(int value) {
    return NodeParameter_NodeType_IsValid(value);
  }
  static const NodeType NodeType_MIN =
    NodeParameter_NodeType_NodeType_MIN;
  static const NodeType NodeType_MAX =
    NodeParameter_NodeType_NodeType_MAX;
  static const int NodeType_ARRAYSIZE =
    NodeParameter_NodeType_NodeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NodeType_descriptor() {
    return NodeParameter_NodeType_descriptor();
  }
  static inline const ::std::string& NodeType_Name(NodeType value) {
    return NodeParameter_NodeType_Name(value);
  }
  static inline bool NodeType_Parse(const ::std::string& name,
      NodeType* value) {
    return NodeParameter_NodeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 tree_id = 8;
  inline bool has_tree_id() const;
  inline void clear_tree_id();
  static const int kTreeIdFieldNumber = 8;
  inline ::google::protobuf::int32 tree_id() const;
  inline void set_tree_id(::google::protobuf::int32 value);

  // optional float test_accuracy = 9;
  inline bool has_test_accuracy() const;
  inline void clear_test_accuracy();
  static const int kTestAccuracyFieldNumber = 9;
  inline float test_accuracy() const;
  inline void set_test_accuracy(float value);

  // optional float train_accuracy = 10;
  inline bool has_train_accuracy() const;
  inline void clear_train_accuracy();
  static const int kTrainAccuracyFieldNumber = 10;
  inline float train_accuracy() const;
  inline void set_train_accuracy(float value);

  // optional float test_loss = 11;
  inline bool has_test_loss() const;
  inline void clear_test_loss();
  static const int kTestLossFieldNumber = 11;
  inline float test_loss() const;
  inline void set_test_loss(float value);

  // optional float train_loss = 12;
  inline bool has_train_loss() const;
  inline void clear_train_loss();
  static const int kTrainLossFieldNumber = 12;
  inline float train_loss() const;
  inline void set_train_loss(float value);

  // optional int32 nleaves = 13;
  inline bool has_nleaves() const;
  inline void clear_nleaves();
  static const int kNleavesFieldNumber = 13;
  inline ::google::protobuf::int32 nleaves() const;
  inline void set_nleaves(::google::protobuf::int32 value);

  // required .bvdt.NodeParameter.NodeType node_type = 3;
  inline bool has_node_type() const;
  inline void clear_node_type();
  static const int kNodeTypeFieldNumber = 3;
  inline ::bvdt::NodeParameter_NodeType node_type() const;
  inline void set_node_type(::bvdt::NodeParameter_NodeType value);

  // optional float cut = 1;
  inline bool has_cut() const;
  inline void clear_cut();
  static const int kCutFieldNumber = 1;
  inline float cut() const;
  inline void set_cut(float value);

  // optional int32 feature = 2 [default = 0];
  inline bool has_feature() const;
  inline void clear_feature();
  static const int kFeatureFieldNumber = 2;
  inline ::google::protobuf::int32 feature() const;
  inline void set_feature(::google::protobuf::int32 value);

  // optional float value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline float value() const;
  inline void set_value(float value);

  // optional int32 mode_id = 5;
  inline bool has_mode_id() const;
  inline void clear_mode_id();
  static const int kModeIdFieldNumber = 5;
  inline ::google::protobuf::int32 mode_id() const;
  inline void set_mode_id(::google::protobuf::int32 value);

  // optional .bvdt.NodeParameter left_child = 6;
  inline bool has_left_child() const;
  inline void clear_left_child();
  static const int kLeftChildFieldNumber = 6;
  inline const ::bvdt::NodeParameter& left_child() const;
  inline ::bvdt::NodeParameter* mutable_left_child();
  inline ::bvdt::NodeParameter* release_left_child();
  inline void set_allocated_left_child(::bvdt::NodeParameter* left_child);

  // optional .bvdt.NodeParameter right_child = 7;
  inline bool has_right_child() const;
  inline void clear_right_child();
  static const int kRightChildFieldNumber = 7;
  inline const ::bvdt::NodeParameter& right_child() const;
  inline ::bvdt::NodeParameter* mutable_right_child();
  inline ::bvdt::NodeParameter* release_right_child();
  inline void set_allocated_right_child(::bvdt::NodeParameter* right_child);

  // @@protoc_insertion_point(class_scope:bvdt.NodeParameter)
 private:
  inline void set_has_tree_id();
  inline void clear_has_tree_id();
  inline void set_has_test_accuracy();
  inline void clear_has_test_accuracy();
  inline void set_has_train_accuracy();
  inline void clear_has_train_accuracy();
  inline void set_has_test_loss();
  inline void clear_has_test_loss();
  inline void set_has_train_loss();
  inline void clear_has_train_loss();
  inline void set_has_nleaves();
  inline void clear_has_nleaves();
  inline void set_has_node_type();
  inline void clear_has_node_type();
  inline void set_has_cut();
  inline void clear_has_cut();
  inline void set_has_feature();
  inline void clear_has_feature();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_mode_id();
  inline void clear_has_mode_id();
  inline void set_has_left_child();
  inline void clear_has_left_child();
  inline void set_has_right_child();
  inline void clear_has_right_child();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 tree_id_;
  float test_accuracy_;
  float train_accuracy_;
  float test_loss_;
  float train_loss_;
  ::google::protobuf::int32 nleaves_;
  int node_type_;
  float cut_;
  ::google::protobuf::int32 feature_;
  float value_;
  ::bvdt::NodeParameter* left_child_;
  ::bvdt::NodeParameter* right_child_;
  ::google::protobuf::int32 mode_id_;
  friend void  protobuf_AddDesc_algo_2eproto();
  friend void protobuf_AssignDesc_algo_2eproto();
  friend void protobuf_ShutdownFile_algo_2eproto();

  void InitAsDefaultInstance();
  static NodeParameter* default_instance_;
};
// -------------------------------------------------------------------

class TreeParameter : public ::google::protobuf::Message {
 public:
  TreeParameter();
  virtual ~TreeParameter();

  TreeParameter(const TreeParameter& from);

  inline TreeParameter& operator=(const TreeParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TreeParameter& default_instance();

  void Swap(TreeParameter* other);

  // implements Message ----------------------------------------------

  TreeParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TreeParameter& from);
  void MergeFrom(const TreeParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 nvariables = 1;
  inline bool has_nvariables() const;
  inline void clear_nvariables();
  static const int kNvariablesFieldNumber = 1;
  inline ::google::protobuf::int32 nvariables() const;
  inline void set_nvariables(::google::protobuf::int32 value);

  // required int32 nclass_label = 2;
  inline bool has_nclass_label() const;
  inline void clear_nclass_label();
  static const int kNclassLabelFieldNumber = 2;
  inline ::google::protobuf::int32 nclass_label() const;
  inline void set_nclass_label(::google::protobuf::int32 value);

  // required .bvdt.__NodeMode_ node_type = 3;
  inline bool has_node_type() const;
  inline void clear_node_type();
  static const int kNodeTypeFieldNumber = 3;
  inline ::bvdt::__NodeMode_ node_type() const;
  inline void set_node_type(::bvdt::__NodeMode_ value);

  // required int32 nleaves = 5;
  inline bool has_nleaves() const;
  inline void clear_nleaves();
  static const int kNleavesFieldNumber = 5;
  inline ::google::protobuf::int32 nleaves() const;
  inline void set_nleaves(::google::protobuf::int32 value);

  // optional float shrinkage = 6 [default = 1];
  inline bool has_shrinkage() const;
  inline void clear_shrinkage();
  static const int kShrinkageFieldNumber = 6;
  inline float shrinkage() const;
  inline void set_shrinkage(float value);

  // repeated .bvdt.NodeParameter root_nodes = 4;
  inline int root_nodes_size() const;
  inline void clear_root_nodes();
  static const int kRootNodesFieldNumber = 4;
  inline const ::bvdt::NodeParameter& root_nodes(int index) const;
  inline ::bvdt::NodeParameter* mutable_root_nodes(int index);
  inline ::bvdt::NodeParameter* add_root_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::bvdt::NodeParameter >&
      root_nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::bvdt::NodeParameter >*
      mutable_root_nodes();

  // @@protoc_insertion_point(class_scope:bvdt.TreeParameter)
 private:
  inline void set_has_nvariables();
  inline void clear_has_nvariables();
  inline void set_has_nclass_label();
  inline void clear_has_nclass_label();
  inline void set_has_node_type();
  inline void clear_has_node_type();
  inline void set_has_nleaves();
  inline void clear_has_nleaves();
  inline void set_has_shrinkage();
  inline void clear_has_shrinkage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 nvariables_;
  ::google::protobuf::int32 nclass_label_;
  int node_type_;
  ::google::protobuf::int32 nleaves_;
  ::google::protobuf::RepeatedPtrField< ::bvdt::NodeParameter > root_nodes_;
  float shrinkage_;
  friend void  protobuf_AddDesc_algo_2eproto();
  friend void protobuf_AssignDesc_algo_2eproto();
  friend void protobuf_ShutdownFile_algo_2eproto();

  void InitAsDefaultInstance();
  static TreeParameter* default_instance_;
};
// ===================================================================


// ===================================================================

// SolverParameter

// required int32 nleaves = 1;
inline bool SolverParameter::has_nleaves() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolverParameter::set_has_nleaves() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolverParameter::clear_has_nleaves() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolverParameter::clear_nleaves() {
  nleaves_ = 0;
  clear_has_nleaves();
}
inline ::google::protobuf::int32 SolverParameter::nleaves() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.nleaves)
  return nleaves_;
}
inline void SolverParameter::set_nleaves(::google::protobuf::int32 value) {
  set_has_nleaves();
  nleaves_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.nleaves)
}

// optional float convergence_rate = 36 [default = 0];
inline bool SolverParameter::has_convergence_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolverParameter::set_has_convergence_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolverParameter::clear_has_convergence_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolverParameter::clear_convergence_rate() {
  convergence_rate_ = 0;
  clear_has_convergence_rate();
}
inline float SolverParameter::convergence_rate() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.convergence_rate)
  return convergence_rate_;
}
inline void SolverParameter::set_convergence_rate(float value) {
  set_has_convergence_rate();
  convergence_rate_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.convergence_rate)
}

// required int32 nclass_label = 2;
inline bool SolverParameter::has_nclass_label() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SolverParameter::set_has_nclass_label() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SolverParameter::clear_has_nclass_label() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SolverParameter::clear_nclass_label() {
  nclass_label_ = 0;
  clear_has_nclass_label();
}
inline ::google::protobuf::int32 SolverParameter::nclass_label() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.nclass_label)
  return nclass_label_;
}
inline void SolverParameter::set_nclass_label(::google::protobuf::int32 value) {
  set_has_nclass_label();
  nclass_label_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.nclass_label)
}

// required int32 nfeatures = 16;
inline bool SolverParameter::has_nfeatures() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SolverParameter::set_has_nfeatures() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SolverParameter::clear_has_nfeatures() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SolverParameter::clear_nfeatures() {
  nfeatures_ = 0;
  clear_has_nfeatures();
}
inline ::google::protobuf::int32 SolverParameter::nfeatures() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.nfeatures)
  return nfeatures_;
}
inline void SolverParameter::set_nfeatures(::google::protobuf::int32 value) {
  set_has_nfeatures();
  nfeatures_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.nfeatures)
}

// required int32 nmaximum_trees = 22;
inline bool SolverParameter::has_nmaximum_trees() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SolverParameter::set_has_nmaximum_trees() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SolverParameter::clear_has_nmaximum_trees() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SolverParameter::clear_nmaximum_trees() {
  nmaximum_trees_ = 0;
  clear_has_nmaximum_trees();
}
inline ::google::protobuf::int32 SolverParameter::nmaximum_trees() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.nmaximum_trees)
  return nmaximum_trees_;
}
inline void SolverParameter::set_nmaximum_trees(::google::protobuf::int32 value) {
  set_has_nmaximum_trees();
  nmaximum_trees_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.nmaximum_trees)
}

// optional float maxz = 3 [default = 4];
inline bool SolverParameter::has_maxz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SolverParameter::set_has_maxz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SolverParameter::clear_has_maxz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SolverParameter::clear_maxz() {
  maxz_ = 4;
  clear_has_maxz();
}
inline float SolverParameter::maxz() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.maxz)
  return maxz_;
}
inline void SolverParameter::set_maxz(float value) {
  set_has_maxz();
  maxz_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.maxz)
}

// optional float shrinkage = 11 [default = 1];
inline bool SolverParameter::has_shrinkage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SolverParameter::set_has_shrinkage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SolverParameter::clear_has_shrinkage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SolverParameter::clear_shrinkage() {
  shrinkage_ = 1;
  clear_has_shrinkage();
}
inline float SolverParameter::shrinkage() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.shrinkage)
  return shrinkage_;
}
inline void SolverParameter::set_shrinkage(float value) {
  set_has_shrinkage();
  shrinkage_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.shrinkage)
}

// required string snapshot = 18;
inline bool SolverParameter::has_snapshot() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SolverParameter::set_has_snapshot() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SolverParameter::clear_has_snapshot() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SolverParameter::clear_snapshot() {
  if (snapshot_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    snapshot_->clear();
  }
  clear_has_snapshot();
}
inline const ::std::string& SolverParameter::snapshot() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.snapshot)
  return *snapshot_;
}
inline void SolverParameter::set_snapshot(const ::std::string& value) {
  set_has_snapshot();
  if (snapshot_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    snapshot_ = new ::std::string;
  }
  snapshot_->assign(value);
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.snapshot)
}
inline void SolverParameter::set_snapshot(const char* value) {
  set_has_snapshot();
  if (snapshot_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    snapshot_ = new ::std::string;
  }
  snapshot_->assign(value);
  // @@protoc_insertion_point(field_set_char:bvdt.SolverParameter.snapshot)
}
inline void SolverParameter::set_snapshot(const char* value, size_t size) {
  set_has_snapshot();
  if (snapshot_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    snapshot_ = new ::std::string;
  }
  snapshot_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bvdt.SolverParameter.snapshot)
}
inline ::std::string* SolverParameter::mutable_snapshot() {
  set_has_snapshot();
  if (snapshot_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    snapshot_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bvdt.SolverParameter.snapshot)
  return snapshot_;
}
inline ::std::string* SolverParameter::release_snapshot() {
  clear_has_snapshot();
  if (snapshot_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = snapshot_;
    snapshot_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SolverParameter::set_allocated_snapshot(::std::string* snapshot) {
  if (snapshot_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete snapshot_;
  }
  if (snapshot) {
    set_has_snapshot();
    snapshot_ = snapshot;
  } else {
    clear_has_snapshot();
    snapshot_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bvdt.SolverParameter.snapshot)
}

// optional int32 snapshot_interval = 17 [default = 100];
inline bool SolverParameter::has_snapshot_interval() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SolverParameter::set_has_snapshot_interval() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SolverParameter::clear_has_snapshot_interval() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SolverParameter::clear_snapshot_interval() {
  snapshot_interval_ = 100;
  clear_has_snapshot_interval();
}
inline ::google::protobuf::int32 SolverParameter::snapshot_interval() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.snapshot_interval)
  return snapshot_interval_;
}
inline void SolverParameter::set_snapshot_interval(::google::protobuf::int32 value) {
  set_has_snapshot_interval();
  snapshot_interval_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.snapshot_interval)
}

// optional int32 reshuffle_interval = 35 [default = 0];
inline bool SolverParameter::has_reshuffle_interval() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SolverParameter::set_has_reshuffle_interval() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SolverParameter::clear_has_reshuffle_interval() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SolverParameter::clear_reshuffle_interval() {
  reshuffle_interval_ = 0;
  clear_has_reshuffle_interval();
}
inline ::google::protobuf::int32 SolverParameter::reshuffle_interval() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.reshuffle_interval)
  return reshuffle_interval_;
}
inline void SolverParameter::set_reshuffle_interval(::google::protobuf::int32 value) {
  set_has_reshuffle_interval();
  reshuffle_interval_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.reshuffle_interval)
}

// required string train_data = 20;
inline bool SolverParameter::has_train_data() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SolverParameter::set_has_train_data() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SolverParameter::clear_has_train_data() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SolverParameter::clear_train_data() {
  if (train_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    train_data_->clear();
  }
  clear_has_train_data();
}
inline const ::std::string& SolverParameter::train_data() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.train_data)
  return *train_data_;
}
inline void SolverParameter::set_train_data(const ::std::string& value) {
  set_has_train_data();
  if (train_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    train_data_ = new ::std::string;
  }
  train_data_->assign(value);
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.train_data)
}
inline void SolverParameter::set_train_data(const char* value) {
  set_has_train_data();
  if (train_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    train_data_ = new ::std::string;
  }
  train_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:bvdt.SolverParameter.train_data)
}
inline void SolverParameter::set_train_data(const char* value, size_t size) {
  set_has_train_data();
  if (train_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    train_data_ = new ::std::string;
  }
  train_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bvdt.SolverParameter.train_data)
}
inline ::std::string* SolverParameter::mutable_train_data() {
  set_has_train_data();
  if (train_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    train_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bvdt.SolverParameter.train_data)
  return train_data_;
}
inline ::std::string* SolverParameter::release_train_data() {
  clear_has_train_data();
  if (train_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = train_data_;
    train_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SolverParameter::set_allocated_train_data(::std::string* train_data) {
  if (train_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete train_data_;
  }
  if (train_data) {
    set_has_train_data();
    train_data_ = train_data;
  } else {
    clear_has_train_data();
    train_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bvdt.SolverParameter.train_data)
}

// required int32 ntrain_samples = 28;
inline bool SolverParameter::has_ntrain_samples() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SolverParameter::set_has_ntrain_samples() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SolverParameter::clear_has_ntrain_samples() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SolverParameter::clear_ntrain_samples() {
  ntrain_samples_ = 0;
  clear_has_ntrain_samples();
}
inline ::google::protobuf::int32 SolverParameter::ntrain_samples() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.ntrain_samples)
  return ntrain_samples_;
}
inline void SolverParameter::set_ntrain_samples(::google::protobuf::int32 value) {
  set_has_ntrain_samples();
  ntrain_samples_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.ntrain_samples)
}

// optional string test_data = 21;
inline bool SolverParameter::has_test_data() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SolverParameter::set_has_test_data() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SolverParameter::clear_has_test_data() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SolverParameter::clear_test_data() {
  if (test_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    test_data_->clear();
  }
  clear_has_test_data();
}
inline const ::std::string& SolverParameter::test_data() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.test_data)
  return *test_data_;
}
inline void SolverParameter::set_test_data(const ::std::string& value) {
  set_has_test_data();
  if (test_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    test_data_ = new ::std::string;
  }
  test_data_->assign(value);
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.test_data)
}
inline void SolverParameter::set_test_data(const char* value) {
  set_has_test_data();
  if (test_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    test_data_ = new ::std::string;
  }
  test_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:bvdt.SolverParameter.test_data)
}
inline void SolverParameter::set_test_data(const char* value, size_t size) {
  set_has_test_data();
  if (test_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    test_data_ = new ::std::string;
  }
  test_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bvdt.SolverParameter.test_data)
}
inline ::std::string* SolverParameter::mutable_test_data() {
  set_has_test_data();
  if (test_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    test_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bvdt.SolverParameter.test_data)
  return test_data_;
}
inline ::std::string* SolverParameter::release_test_data() {
  clear_has_test_data();
  if (test_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = test_data_;
    test_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SolverParameter::set_allocated_test_data(::std::string* test_data) {
  if (test_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete test_data_;
  }
  if (test_data) {
    set_has_test_data();
    test_data_ = test_data;
  } else {
    clear_has_test_data();
    test_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bvdt.SolverParameter.test_data)
}

// optional int32 ntest_samples = 29;
inline bool SolverParameter::has_ntest_samples() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SolverParameter::set_has_ntest_samples() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SolverParameter::clear_has_ntest_samples() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SolverParameter::clear_ntest_samples() {
  ntest_samples_ = 0;
  clear_has_ntest_samples();
}
inline ::google::protobuf::int32 SolverParameter::ntest_samples() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.ntest_samples)
  return ntest_samples_;
}
inline void SolverParameter::set_ntest_samples(::google::protobuf::int32 value) {
  set_has_ntest_samples();
  ntest_samples_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.ntest_samples)
}

// optional int32 display = 33 [default = 1];
inline bool SolverParameter::has_display() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SolverParameter::set_has_display() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SolverParameter::clear_has_display() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SolverParameter::clear_display() {
  display_ = 1;
  clear_has_display();
}
inline ::google::protobuf::int32 SolverParameter::display() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.display)
  return display_;
}
inline void SolverParameter::set_display(::google::protobuf::int32 value) {
  set_has_display();
  display_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.display)
}

// optional bool save_accuracy = 34 [default = false];
inline bool SolverParameter::has_save_accuracy() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SolverParameter::set_has_save_accuracy() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SolverParameter::clear_has_save_accuracy() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SolverParameter::clear_save_accuracy() {
  save_accuracy_ = false;
  clear_has_save_accuracy();
}
inline bool SolverParameter::save_accuracy() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.save_accuracy)
  return save_accuracy_;
}
inline void SolverParameter::set_save_accuracy(bool value) {
  set_has_save_accuracy();
  save_accuracy_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.save_accuracy)
}

// optional .bvdt.SolverParameter.RegularizationType regularization_type_split = 12 [default = NO_REGULARIZATION];
inline bool SolverParameter::has_regularization_type_split() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SolverParameter::set_has_regularization_type_split() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SolverParameter::clear_has_regularization_type_split() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SolverParameter::clear_regularization_type_split() {
  regularization_type_split_ = 0;
  clear_has_regularization_type_split();
}
inline ::bvdt::SolverParameter_RegularizationType SolverParameter::regularization_type_split() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.regularization_type_split)
  return static_cast< ::bvdt::SolverParameter_RegularizationType >(regularization_type_split_);
}
inline void SolverParameter::set_regularization_type_split(::bvdt::SolverParameter_RegularizationType value) {
  assert(::bvdt::SolverParameter_RegularizationType_IsValid(value));
  set_has_regularization_type_split();
  regularization_type_split_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.regularization_type_split)
}

// optional float regularization_split = 13;
inline bool SolverParameter::has_regularization_split() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SolverParameter::set_has_regularization_split() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SolverParameter::clear_has_regularization_split() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SolverParameter::clear_regularization_split() {
  regularization_split_ = 0;
  clear_has_regularization_split();
}
inline float SolverParameter::regularization_split() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.regularization_split)
  return regularization_split_;
}
inline void SolverParameter::set_regularization_split(float value) {
  set_has_regularization_split();
  regularization_split_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.regularization_split)
}

// optional float regularization_ratio_split = 14;
inline bool SolverParameter::has_regularization_ratio_split() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SolverParameter::set_has_regularization_ratio_split() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SolverParameter::clear_has_regularization_ratio_split() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SolverParameter::clear_regularization_ratio_split() {
  regularization_ratio_split_ = 0;
  clear_has_regularization_ratio_split();
}
inline float SolverParameter::regularization_ratio_split() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.regularization_ratio_split)
  return regularization_ratio_split_;
}
inline void SolverParameter::set_regularization_ratio_split(float value) {
  set_has_regularization_ratio_split();
  regularization_ratio_split_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.regularization_ratio_split)
}

// optional .bvdt.SolverParameter.RegularizationType regularization_type_leaf = 30 [default = NO_REGULARIZATION];
inline bool SolverParameter::has_regularization_type_leaf() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SolverParameter::set_has_regularization_type_leaf() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SolverParameter::clear_has_regularization_type_leaf() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SolverParameter::clear_regularization_type_leaf() {
  regularization_type_leaf_ = 0;
  clear_has_regularization_type_leaf();
}
inline ::bvdt::SolverParameter_RegularizationType SolverParameter::regularization_type_leaf() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.regularization_type_leaf)
  return static_cast< ::bvdt::SolverParameter_RegularizationType >(regularization_type_leaf_);
}
inline void SolverParameter::set_regularization_type_leaf(::bvdt::SolverParameter_RegularizationType value) {
  assert(::bvdt::SolverParameter_RegularizationType_IsValid(value));
  set_has_regularization_type_leaf();
  regularization_type_leaf_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.regularization_type_leaf)
}

// optional float regularization_leaf = 31;
inline bool SolverParameter::has_regularization_leaf() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SolverParameter::set_has_regularization_leaf() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SolverParameter::clear_has_regularization_leaf() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SolverParameter::clear_regularization_leaf() {
  regularization_leaf_ = 0;
  clear_has_regularization_leaf();
}
inline float SolverParameter::regularization_leaf() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.regularization_leaf)
  return regularization_leaf_;
}
inline void SolverParameter::set_regularization_leaf(float value) {
  set_has_regularization_leaf();
  regularization_leaf_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.regularization_leaf)
}

// optional float regularization_ratio_leaf = 32;
inline bool SolverParameter::has_regularization_ratio_leaf() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SolverParameter::set_has_regularization_ratio_leaf() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SolverParameter::clear_has_regularization_ratio_leaf() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SolverParameter::clear_regularization_ratio_leaf() {
  regularization_ratio_leaf_ = 0;
  clear_has_regularization_ratio_leaf();
}
inline float SolverParameter::regularization_ratio_leaf() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.regularization_ratio_leaf)
  return regularization_ratio_leaf_;
}
inline void SolverParameter::set_regularization_ratio_leaf(float value) {
  set_has_regularization_ratio_leaf();
  regularization_ratio_leaf_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.regularization_ratio_leaf)
}

// required float event_sample_rate = 4 [default = 1];
inline bool SolverParameter::has_event_sample_rate() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SolverParameter::set_has_event_sample_rate() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SolverParameter::clear_has_event_sample_rate() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SolverParameter::clear_event_sample_rate() {
  event_sample_rate_ = 1;
  clear_has_event_sample_rate();
}
inline float SolverParameter::event_sample_rate() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.event_sample_rate)
  return event_sample_rate_;
}
inline void SolverParameter::set_event_sample_rate(float value) {
  set_has_event_sample_rate();
  event_sample_rate_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.event_sample_rate)
}

// required float node_mode_sample_rate = 5 [default = 1];
inline bool SolverParameter::has_node_mode_sample_rate() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SolverParameter::set_has_node_mode_sample_rate() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SolverParameter::clear_has_node_mode_sample_rate() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SolverParameter::clear_node_mode_sample_rate() {
  node_mode_sample_rate_ = 1;
  clear_has_node_mode_sample_rate();
}
inline float SolverParameter::node_mode_sample_rate() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.node_mode_sample_rate)
  return node_mode_sample_rate_;
}
inline void SolverParameter::set_node_mode_sample_rate(float value) {
  set_has_node_mode_sample_rate();
  node_mode_sample_rate_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.node_mode_sample_rate)
}

// required float feature_sample_rate = 6 [default = 1];
inline bool SolverParameter::has_feature_sample_rate() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void SolverParameter::set_has_feature_sample_rate() {
  _has_bits_[0] |= 0x01000000u;
}
inline void SolverParameter::clear_has_feature_sample_rate() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void SolverParameter::clear_feature_sample_rate() {
  feature_sample_rate_ = 1;
  clear_has_feature_sample_rate();
}
inline float SolverParameter::feature_sample_rate() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.feature_sample_rate)
  return feature_sample_rate_;
}
inline void SolverParameter::set_feature_sample_rate(float value) {
  set_has_feature_sample_rate();
  feature_sample_rate_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.feature_sample_rate)
}

// required .bvdt.SolverParameter.DirectionType direction_type = 15 [default = FULL_SEARCH];
inline bool SolverParameter::has_direction_type() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void SolverParameter::set_has_direction_type() {
  _has_bits_[0] |= 0x02000000u;
}
inline void SolverParameter::clear_has_direction_type() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void SolverParameter::clear_direction_type() {
  direction_type_ = 0;
  clear_has_direction_type();
}
inline ::bvdt::SolverParameter_DirectionType SolverParameter::direction_type() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.direction_type)
  return static_cast< ::bvdt::SolverParameter_DirectionType >(direction_type_);
}
inline void SolverParameter::set_direction_type(::bvdt::SolverParameter_DirectionType value) {
  assert(::bvdt::SolverParameter_DirectionType_IsValid(value));
  set_has_direction_type();
  direction_type_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.direction_type)
}

// required .bvdt.SolverParameter.LeafValueData leaf_value_data = 7;
inline bool SolverParameter::has_leaf_value_data() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void SolverParameter::set_has_leaf_value_data() {
  _has_bits_[0] |= 0x04000000u;
}
inline void SolverParameter::clear_has_leaf_value_data() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void SolverParameter::clear_leaf_value_data() {
  leaf_value_data_ = 0;
  clear_has_leaf_value_data();
}
inline ::bvdt::SolverParameter_LeafValueData SolverParameter::leaf_value_data() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.leaf_value_data)
  return static_cast< ::bvdt::SolverParameter_LeafValueData >(leaf_value_data_);
}
inline void SolverParameter::set_leaf_value_data(::bvdt::SolverParameter_LeafValueData value) {
  assert(::bvdt::SolverParameter_LeafValueData_IsValid(value));
  set_has_leaf_value_data();
  leaf_value_data_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.leaf_value_data)
}

// required .bvdt.SolverParameter.NodeSplitType node_split_type = 8;
inline bool SolverParameter::has_node_split_type() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void SolverParameter::set_has_node_split_type() {
  _has_bits_[0] |= 0x08000000u;
}
inline void SolverParameter::clear_has_node_split_type() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void SolverParameter::clear_node_split_type() {
  node_split_type_ = 0;
  clear_has_node_split_type();
}
inline ::bvdt::SolverParameter_NodeSplitType SolverParameter::node_split_type() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.node_split_type)
  return static_cast< ::bvdt::SolverParameter_NodeSplitType >(node_split_type_);
}
inline void SolverParameter::set_node_split_type(::bvdt::SolverParameter_NodeSplitType value) {
  assert(::bvdt::SolverParameter_NodeSplitType_IsValid(value));
  set_has_node_split_type();
  node_split_type_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.node_split_type)
}

// required .bvdt.SolverParameter.NodeSplitType leaf_value_type = 27;
inline bool SolverParameter::has_leaf_value_type() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void SolverParameter::set_has_leaf_value_type() {
  _has_bits_[0] |= 0x10000000u;
}
inline void SolverParameter::clear_has_leaf_value_type() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void SolverParameter::clear_leaf_value_type() {
  leaf_value_type_ = 0;
  clear_has_leaf_value_type();
}
inline ::bvdt::SolverParameter_NodeSplitType SolverParameter::leaf_value_type() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.leaf_value_type)
  return static_cast< ::bvdt::SolverParameter_NodeSplitType >(leaf_value_type_);
}
inline void SolverParameter::set_leaf_value_type(::bvdt::SolverParameter_NodeSplitType value) {
  assert(::bvdt::SolverParameter_NodeSplitType_IsValid(value));
  set_has_leaf_value_type();
  leaf_value_type_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.leaf_value_type)
}

// required .bvdt.__NodeMode_ node_type = 9;
inline bool SolverParameter::has_node_type() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void SolverParameter::set_has_node_type() {
  _has_bits_[0] |= 0x20000000u;
}
inline void SolverParameter::clear_has_node_type() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void SolverParameter::clear_node_type() {
  node_type_ = 0;
  clear_has_node_type();
}
inline ::bvdt::__NodeMode_ SolverParameter::node_type() const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.node_type)
  return static_cast< ::bvdt::__NodeMode_ >(node_type_);
}
inline void SolverParameter::set_node_type(::bvdt::__NodeMode_ value) {
  assert(::bvdt::__NodeMode__IsValid(value));
  set_has_node_type();
  node_type_ = value;
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.node_type)
}

// repeated float node_mode_param = 37;
inline int SolverParameter::node_mode_param_size() const {
  return node_mode_param_.size();
}
inline void SolverParameter::clear_node_mode_param() {
  node_mode_param_.Clear();
}
inline float SolverParameter::node_mode_param(int index) const {
  // @@protoc_insertion_point(field_get:bvdt.SolverParameter.node_mode_param)
  return node_mode_param_.Get(index);
}
inline void SolverParameter::set_node_mode_param(int index, float value) {
  node_mode_param_.Set(index, value);
  // @@protoc_insertion_point(field_set:bvdt.SolverParameter.node_mode_param)
}
inline void SolverParameter::add_node_mode_param(float value) {
  node_mode_param_.Add(value);
  // @@protoc_insertion_point(field_add:bvdt.SolverParameter.node_mode_param)
}
inline const ::google::protobuf::RepeatedField< float >&
SolverParameter::node_mode_param() const {
  // @@protoc_insertion_point(field_list:bvdt.SolverParameter.node_mode_param)
  return node_mode_param_;
}
inline ::google::protobuf::RepeatedField< float >*
SolverParameter::mutable_node_mode_param() {
  // @@protoc_insertion_point(field_mutable_list:bvdt.SolverParameter.node_mode_param)
  return &node_mode_param_;
}

// -------------------------------------------------------------------

// NodeParameter

// optional int32 tree_id = 8;
inline bool NodeParameter::has_tree_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeParameter::set_has_tree_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeParameter::clear_has_tree_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeParameter::clear_tree_id() {
  tree_id_ = 0;
  clear_has_tree_id();
}
inline ::google::protobuf::int32 NodeParameter::tree_id() const {
  // @@protoc_insertion_point(field_get:bvdt.NodeParameter.tree_id)
  return tree_id_;
}
inline void NodeParameter::set_tree_id(::google::protobuf::int32 value) {
  set_has_tree_id();
  tree_id_ = value;
  // @@protoc_insertion_point(field_set:bvdt.NodeParameter.tree_id)
}

// optional float test_accuracy = 9;
inline bool NodeParameter::has_test_accuracy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeParameter::set_has_test_accuracy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeParameter::clear_has_test_accuracy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeParameter::clear_test_accuracy() {
  test_accuracy_ = 0;
  clear_has_test_accuracy();
}
inline float NodeParameter::test_accuracy() const {
  // @@protoc_insertion_point(field_get:bvdt.NodeParameter.test_accuracy)
  return test_accuracy_;
}
inline void NodeParameter::set_test_accuracy(float value) {
  set_has_test_accuracy();
  test_accuracy_ = value;
  // @@protoc_insertion_point(field_set:bvdt.NodeParameter.test_accuracy)
}

// optional float train_accuracy = 10;
inline bool NodeParameter::has_train_accuracy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeParameter::set_has_train_accuracy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeParameter::clear_has_train_accuracy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeParameter::clear_train_accuracy() {
  train_accuracy_ = 0;
  clear_has_train_accuracy();
}
inline float NodeParameter::train_accuracy() const {
  // @@protoc_insertion_point(field_get:bvdt.NodeParameter.train_accuracy)
  return train_accuracy_;
}
inline void NodeParameter::set_train_accuracy(float value) {
  set_has_train_accuracy();
  train_accuracy_ = value;
  // @@protoc_insertion_point(field_set:bvdt.NodeParameter.train_accuracy)
}

// optional float test_loss = 11;
inline bool NodeParameter::has_test_loss() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeParameter::set_has_test_loss() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeParameter::clear_has_test_loss() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeParameter::clear_test_loss() {
  test_loss_ = 0;
  clear_has_test_loss();
}
inline float NodeParameter::test_loss() const {
  // @@protoc_insertion_point(field_get:bvdt.NodeParameter.test_loss)
  return test_loss_;
}
inline void NodeParameter::set_test_loss(float value) {
  set_has_test_loss();
  test_loss_ = value;
  // @@protoc_insertion_point(field_set:bvdt.NodeParameter.test_loss)
}

// optional float train_loss = 12;
inline bool NodeParameter::has_train_loss() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NodeParameter::set_has_train_loss() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NodeParameter::clear_has_train_loss() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NodeParameter::clear_train_loss() {
  train_loss_ = 0;
  clear_has_train_loss();
}
inline float NodeParameter::train_loss() const {
  // @@protoc_insertion_point(field_get:bvdt.NodeParameter.train_loss)
  return train_loss_;
}
inline void NodeParameter::set_train_loss(float value) {
  set_has_train_loss();
  train_loss_ = value;
  // @@protoc_insertion_point(field_set:bvdt.NodeParameter.train_loss)
}

// optional int32 nleaves = 13;
inline bool NodeParameter::has_nleaves() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NodeParameter::set_has_nleaves() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NodeParameter::clear_has_nleaves() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NodeParameter::clear_nleaves() {
  nleaves_ = 0;
  clear_has_nleaves();
}
inline ::google::protobuf::int32 NodeParameter::nleaves() const {
  // @@protoc_insertion_point(field_get:bvdt.NodeParameter.nleaves)
  return nleaves_;
}
inline void NodeParameter::set_nleaves(::google::protobuf::int32 value) {
  set_has_nleaves();
  nleaves_ = value;
  // @@protoc_insertion_point(field_set:bvdt.NodeParameter.nleaves)
}

// required .bvdt.NodeParameter.NodeType node_type = 3;
inline bool NodeParameter::has_node_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NodeParameter::set_has_node_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NodeParameter::clear_has_node_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NodeParameter::clear_node_type() {
  node_type_ = 0;
  clear_has_node_type();
}
inline ::bvdt::NodeParameter_NodeType NodeParameter::node_type() const {
  // @@protoc_insertion_point(field_get:bvdt.NodeParameter.node_type)
  return static_cast< ::bvdt::NodeParameter_NodeType >(node_type_);
}
inline void NodeParameter::set_node_type(::bvdt::NodeParameter_NodeType value) {
  assert(::bvdt::NodeParameter_NodeType_IsValid(value));
  set_has_node_type();
  node_type_ = value;
  // @@protoc_insertion_point(field_set:bvdt.NodeParameter.node_type)
}

// optional float cut = 1;
inline bool NodeParameter::has_cut() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NodeParameter::set_has_cut() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NodeParameter::clear_has_cut() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NodeParameter::clear_cut() {
  cut_ = 0;
  clear_has_cut();
}
inline float NodeParameter::cut() const {
  // @@protoc_insertion_point(field_get:bvdt.NodeParameter.cut)
  return cut_;
}
inline void NodeParameter::set_cut(float value) {
  set_has_cut();
  cut_ = value;
  // @@protoc_insertion_point(field_set:bvdt.NodeParameter.cut)
}

// optional int32 feature = 2 [default = 0];
inline bool NodeParameter::has_feature() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NodeParameter::set_has_feature() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NodeParameter::clear_has_feature() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NodeParameter::clear_feature() {
  feature_ = 0;
  clear_has_feature();
}
inline ::google::protobuf::int32 NodeParameter::feature() const {
  // @@protoc_insertion_point(field_get:bvdt.NodeParameter.feature)
  return feature_;
}
inline void NodeParameter::set_feature(::google::protobuf::int32 value) {
  set_has_feature();
  feature_ = value;
  // @@protoc_insertion_point(field_set:bvdt.NodeParameter.feature)
}

// optional float value = 4;
inline bool NodeParameter::has_value() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NodeParameter::set_has_value() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NodeParameter::clear_has_value() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NodeParameter::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float NodeParameter::value() const {
  // @@protoc_insertion_point(field_get:bvdt.NodeParameter.value)
  return value_;
}
inline void NodeParameter::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:bvdt.NodeParameter.value)
}

// optional int32 mode_id = 5;
inline bool NodeParameter::has_mode_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NodeParameter::set_has_mode_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NodeParameter::clear_has_mode_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NodeParameter::clear_mode_id() {
  mode_id_ = 0;
  clear_has_mode_id();
}
inline ::google::protobuf::int32 NodeParameter::mode_id() const {
  // @@protoc_insertion_point(field_get:bvdt.NodeParameter.mode_id)
  return mode_id_;
}
inline void NodeParameter::set_mode_id(::google::protobuf::int32 value) {
  set_has_mode_id();
  mode_id_ = value;
  // @@protoc_insertion_point(field_set:bvdt.NodeParameter.mode_id)
}

// optional .bvdt.NodeParameter left_child = 6;
inline bool NodeParameter::has_left_child() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NodeParameter::set_has_left_child() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NodeParameter::clear_has_left_child() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NodeParameter::clear_left_child() {
  if (left_child_ != NULL) left_child_->::bvdt::NodeParameter::Clear();
  clear_has_left_child();
}
inline const ::bvdt::NodeParameter& NodeParameter::left_child() const {
  // @@protoc_insertion_point(field_get:bvdt.NodeParameter.left_child)
  return left_child_ != NULL ? *left_child_ : *default_instance_->left_child_;
}
inline ::bvdt::NodeParameter* NodeParameter::mutable_left_child() {
  set_has_left_child();
  if (left_child_ == NULL) left_child_ = new ::bvdt::NodeParameter;
  // @@protoc_insertion_point(field_mutable:bvdt.NodeParameter.left_child)
  return left_child_;
}
inline ::bvdt::NodeParameter* NodeParameter::release_left_child() {
  clear_has_left_child();
  ::bvdt::NodeParameter* temp = left_child_;
  left_child_ = NULL;
  return temp;
}
inline void NodeParameter::set_allocated_left_child(::bvdt::NodeParameter* left_child) {
  delete left_child_;
  left_child_ = left_child;
  if (left_child) {
    set_has_left_child();
  } else {
    clear_has_left_child();
  }
  // @@protoc_insertion_point(field_set_allocated:bvdt.NodeParameter.left_child)
}

// optional .bvdt.NodeParameter right_child = 7;
inline bool NodeParameter::has_right_child() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NodeParameter::set_has_right_child() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NodeParameter::clear_has_right_child() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NodeParameter::clear_right_child() {
  if (right_child_ != NULL) right_child_->::bvdt::NodeParameter::Clear();
  clear_has_right_child();
}
inline const ::bvdt::NodeParameter& NodeParameter::right_child() const {
  // @@protoc_insertion_point(field_get:bvdt.NodeParameter.right_child)
  return right_child_ != NULL ? *right_child_ : *default_instance_->right_child_;
}
inline ::bvdt::NodeParameter* NodeParameter::mutable_right_child() {
  set_has_right_child();
  if (right_child_ == NULL) right_child_ = new ::bvdt::NodeParameter;
  // @@protoc_insertion_point(field_mutable:bvdt.NodeParameter.right_child)
  return right_child_;
}
inline ::bvdt::NodeParameter* NodeParameter::release_right_child() {
  clear_has_right_child();
  ::bvdt::NodeParameter* temp = right_child_;
  right_child_ = NULL;
  return temp;
}
inline void NodeParameter::set_allocated_right_child(::bvdt::NodeParameter* right_child) {
  delete right_child_;
  right_child_ = right_child;
  if (right_child) {
    set_has_right_child();
  } else {
    clear_has_right_child();
  }
  // @@protoc_insertion_point(field_set_allocated:bvdt.NodeParameter.right_child)
}

// -------------------------------------------------------------------

// TreeParameter

// required int32 nvariables = 1;
inline bool TreeParameter::has_nvariables() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TreeParameter::set_has_nvariables() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TreeParameter::clear_has_nvariables() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TreeParameter::clear_nvariables() {
  nvariables_ = 0;
  clear_has_nvariables();
}
inline ::google::protobuf::int32 TreeParameter::nvariables() const {
  // @@protoc_insertion_point(field_get:bvdt.TreeParameter.nvariables)
  return nvariables_;
}
inline void TreeParameter::set_nvariables(::google::protobuf::int32 value) {
  set_has_nvariables();
  nvariables_ = value;
  // @@protoc_insertion_point(field_set:bvdt.TreeParameter.nvariables)
}

// required int32 nclass_label = 2;
inline bool TreeParameter::has_nclass_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TreeParameter::set_has_nclass_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TreeParameter::clear_has_nclass_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TreeParameter::clear_nclass_label() {
  nclass_label_ = 0;
  clear_has_nclass_label();
}
inline ::google::protobuf::int32 TreeParameter::nclass_label() const {
  // @@protoc_insertion_point(field_get:bvdt.TreeParameter.nclass_label)
  return nclass_label_;
}
inline void TreeParameter::set_nclass_label(::google::protobuf::int32 value) {
  set_has_nclass_label();
  nclass_label_ = value;
  // @@protoc_insertion_point(field_set:bvdt.TreeParameter.nclass_label)
}

// required .bvdt.__NodeMode_ node_type = 3;
inline bool TreeParameter::has_node_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TreeParameter::set_has_node_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TreeParameter::clear_has_node_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TreeParameter::clear_node_type() {
  node_type_ = 0;
  clear_has_node_type();
}
inline ::bvdt::__NodeMode_ TreeParameter::node_type() const {
  // @@protoc_insertion_point(field_get:bvdt.TreeParameter.node_type)
  return static_cast< ::bvdt::__NodeMode_ >(node_type_);
}
inline void TreeParameter::set_node_type(::bvdt::__NodeMode_ value) {
  assert(::bvdt::__NodeMode__IsValid(value));
  set_has_node_type();
  node_type_ = value;
  // @@protoc_insertion_point(field_set:bvdt.TreeParameter.node_type)
}

// required int32 nleaves = 5;
inline bool TreeParameter::has_nleaves() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TreeParameter::set_has_nleaves() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TreeParameter::clear_has_nleaves() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TreeParameter::clear_nleaves() {
  nleaves_ = 0;
  clear_has_nleaves();
}
inline ::google::protobuf::int32 TreeParameter::nleaves() const {
  // @@protoc_insertion_point(field_get:bvdt.TreeParameter.nleaves)
  return nleaves_;
}
inline void TreeParameter::set_nleaves(::google::protobuf::int32 value) {
  set_has_nleaves();
  nleaves_ = value;
  // @@protoc_insertion_point(field_set:bvdt.TreeParameter.nleaves)
}

// optional float shrinkage = 6 [default = 1];
inline bool TreeParameter::has_shrinkage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TreeParameter::set_has_shrinkage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TreeParameter::clear_has_shrinkage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TreeParameter::clear_shrinkage() {
  shrinkage_ = 1;
  clear_has_shrinkage();
}
inline float TreeParameter::shrinkage() const {
  // @@protoc_insertion_point(field_get:bvdt.TreeParameter.shrinkage)
  return shrinkage_;
}
inline void TreeParameter::set_shrinkage(float value) {
  set_has_shrinkage();
  shrinkage_ = value;
  // @@protoc_insertion_point(field_set:bvdt.TreeParameter.shrinkage)
}

// repeated .bvdt.NodeParameter root_nodes = 4;
inline int TreeParameter::root_nodes_size() const {
  return root_nodes_.size();
}
inline void TreeParameter::clear_root_nodes() {
  root_nodes_.Clear();
}
inline const ::bvdt::NodeParameter& TreeParameter::root_nodes(int index) const {
  // @@protoc_insertion_point(field_get:bvdt.TreeParameter.root_nodes)
  return root_nodes_.Get(index);
}
inline ::bvdt::NodeParameter* TreeParameter::mutable_root_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:bvdt.TreeParameter.root_nodes)
  return root_nodes_.Mutable(index);
}
inline ::bvdt::NodeParameter* TreeParameter::add_root_nodes() {
  // @@protoc_insertion_point(field_add:bvdt.TreeParameter.root_nodes)
  return root_nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bvdt::NodeParameter >&
TreeParameter::root_nodes() const {
  // @@protoc_insertion_point(field_list:bvdt.TreeParameter.root_nodes)
  return root_nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::bvdt::NodeParameter >*
TreeParameter::mutable_root_nodes() {
  // @@protoc_insertion_point(field_mutable_list:bvdt.TreeParameter.root_nodes)
  return &root_nodes_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace bvdt

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::bvdt::SolverParameter_RegularizationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bvdt::SolverParameter_RegularizationType>() {
  return ::bvdt::SolverParameter_RegularizationType_descriptor();
}
template <> struct is_proto_enum< ::bvdt::SolverParameter_DirectionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bvdt::SolverParameter_DirectionType>() {
  return ::bvdt::SolverParameter_DirectionType_descriptor();
}
template <> struct is_proto_enum< ::bvdt::SolverParameter_LeafValueData> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bvdt::SolverParameter_LeafValueData>() {
  return ::bvdt::SolverParameter_LeafValueData_descriptor();
}
template <> struct is_proto_enum< ::bvdt::SolverParameter_NodeSplitType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bvdt::SolverParameter_NodeSplitType>() {
  return ::bvdt::SolverParameter_NodeSplitType_descriptor();
}
template <> struct is_proto_enum< ::bvdt::NodeParameter_NodeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bvdt::NodeParameter_NodeType>() {
  return ::bvdt::NodeParameter_NodeType_descriptor();
}
template <> struct is_proto_enum< ::bvdt::__NodeMode_> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bvdt::__NodeMode_>() {
  return ::bvdt::__NodeMode__descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_algo_2eproto__INCLUDED
